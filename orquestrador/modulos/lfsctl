#!/usr/bin/env bash
# lfsctl — CLI da suíte LFS/BLFS (Módulo 1 + 2 + 3)
set -euo pipefail

: "${LFS_RUNTIME:=/usr/local/lib/lfs}"
# shellcheck source=/usr/local/lib/lfs/common.sh
. "${LFS_RUNTIME}/common.sh"
# shellcheck source=/usr/local/lib/lfs/downloader.sh
. "${LFS_RUNTIME}/downloader.sh"
# shellcheck source=/usr/local/lib/lfs/chroot.sh
. "${LFS_RUNTIME}/chroot.sh"

VERSION="1.2.0"

usage() {
  cat <<'USAGE'
lfsctl 1.2.0
Uso: lfsctl <comando> [opções]

Core (M1):
  version                     Mostra versão
  init                        Cria diretórios padrão e config inicial
  doctor                      Verifica dependências do ambiente
  status                      Mostra resumo de configuração/paths
  logs [N]                    Mostra as últimas N linhas de log
  log-demo                    Gera entradas de log de teste
  lock test [NAME]            Testa aquisição de lock
  config print                Exibe config efetiva
  config set KEY=VAL [...]    Atualiza/insere chaves

Downloader & Cache (M2):
  fetch url <URL> --sha256 HEX [--sig SIG] [--outdir DIR] [--name FILENAME]
  fetch list <FILE> [--parallel N] [--outdir DIR]
  fetch git --url URL --ref REF --name NAME [--outdir DIR]
  verify <FILE> --sha256 HEX [--sig SIGFILE] [--keyring DIR]
  cache ls [sources|tarballs|git]
  cache clean [sources|tarballs|git|all]

Chroot & Bootstrap (M3):
  chroot init                 Prepara layout bootstrap em /mnt/lfs (hooks pre/post)
  chroot mount                Monta binds (/dev, /proc, /sys, /run, /dev/pts)
  chroot umount               Desmonta binds com segurança
  chroot status               Mostra estado dos mounts do chroot
  chroot enter [-- CMD...]    Entra no chroot (interativo) ou executa CMD
  chroot exec -- CMD...       Executa comando não-interativo dentro do chroot
  destdir run --dest DIR -- CMD...
                              Executa comando com fakeroot e DESTDIR=DIR

Exemplos:
  sudo lfsctl chroot init
  sudo lfsctl chroot mount
  sudo lfsctl chroot enter
  sudo lfsctl chroot exec -- 'echo Hello from chroot'
  sudo lfsctl chroot umount
  lfsctl destdir run --dest /mnt/lfs -- 'make install'
USAGE
}

#-------------------------
# Core (M1) — mesmos comandos
#-------------------------
cmd_version() { echo "lfsctl ${VERSION}"; }
cmd_init()    { assert_root; log_info "Inicializando..."; bootstrap_runtime; log_ok "OK."; print_env_summary | sed 's/^/  - /'; }
cmd_doctor()  { bootstrap_runtime; log_info "Verificando dependências..."; if doctor_checks; then log_ok "Ambiente OK."; else log_error "Dependências faltantes."; exit 2; fi; }
cmd_status()  { bootstrap_runtime; echo "== STATUS =="; print_env_summary; echo; echo "Locks: ${LFS_LOCK_DIR}"; echo "DB: ${LFS_DB_DIR}"; echo "Receitas: ${LFS_RECIPES_DIR}"; echo "Logs: ${LFS_LOG_FILE}"; }
cmd_logs()    { bootstrap_runtime; tail_logs "${1:-200}"; }
cmd_log_demo(){ bootstrap_runtime; log_info "Info"; log_ok "OK"; log_warn "Warn"; log_error "Erro"; log_debug "Debug"; echo "Log: ${LFS_LOG_FILE}"; }
cmd_lock_test(){ bootstrap_runtime; local name="${1:-example}"; log_info "Lock ${name}"; with_flock "${name}" 5 bash -c 'sleep 1'; log_ok "Lock ok"; }
cmd_config_print(){ bootstrap_runtime; echo "# Config efetiva"; print_env_summary; echo; echo "# Arquivos:"; echo "  - ${LFS_DEFAULT_CONFIG_FILE}"; if compgen -G "${LFS_ETC_D}/*.conf" >/dev/null; then for cf in "${LFS_ETC_D}"/*.conf; do echo "  - ${cf}"; done; else echo "  - (sem overrides)"; fi; }
cmd_config_set(){ assert_root; bootstrap_runtime; [[ "$#" -ge 1 ]] || die 2 "Uso: lfsctl config set KEY=VAL [...]"; local kv key val; touch "${LFS_DEFAULT_CONFIG_FILE}"; chmod 0644 "${LFS_DEFAULT_CONFIG_FILE}"; for kv in "$@"; do [[ "$kv" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]] || die 2 "Par inválido: ${kv}"; key="${kv%%=*}"; val="${kv#*=}"; if grep -qE "^${key}=" "${LFS_DEFAULT_CONFIG_FILE}"; then sed -i -E "s|^${key}=.*|${key}=${val}|g" "${LFS_DEFAULT_CONFIG_FILE}"; else echo "${key}=${val}" >> "${LFS_DEFAULT_CONFIG_FILE}"; fi; log_ok "${key}=${val}"; done; }

#-------------------------
# Downloader (M2) — mesmos comandos
#-------------------------
cmd_fetch_url() { dl_bootstrap; local url sha sig="" outdir="${LFS_CACHE}/sources" name=""; [[ "${1:-}" =~ ^https?:// ]] || die 2 "Uso: lfsctl fetch url <URL> --sha256 HEX [--sig SIG] [--outdir DIR] [--name FILENAME]"; url="$1"; shift; while [[ $# -gt 0 ]]; do case "$1" in --sha256) sha="$2"; shift 2;; --sig) sig="$2"; shift 2;; --outdir) outdir="$2"; shift 2;; --name) name="$2"; shift 2;; *) die 2 "Parâmetro inválido: $1";; esac; done; [[ -n "${sha:-}" ]] || die 2 "Falta --sha256"; local fname; if [[ -n "${name}" ]]; then fname="${name}"; else fname="$(basename -- "$url")"; fi; local out="${outdir}/${fname}"; with_flock "fetch" 600 bash -c 'dl_fetch_one "'"${fname}"'" "'"${url}"'" "'"${sha}"'" "'"${sig}"'" "'"${outdir}"'" >/dev/null'; echo "${out}"; }
cmd_fetch_list() { dl_bootstrap; local list="${1:-}"; shift || true; [[ -n "${list}" ]] || die 2 "Uso: lfsctl fetch list <FILE> [--parallel N] [--outdir DIR]"; local parallel="$(effective_jobs)" outdir="${LFS_CACHE}/sources"; while [[ $# -gt 0 ]]; do case "$1" in --parallel) parallel="$2"; shift 2;; --outdir) outdir="$2"; shift 2;; *) die 2 "Parâmetro inválido: $1";; esac; done; with_flock "fetch" 3600 bash -c 'dl_fetch_list "'"${list}"'" "'"${outdir}"'" "'"${parallel}"'"'; }
cmd_fetch_git() { dl_bootstrap; local url="" ref="" name="" outdir="${LFS_CACHE}/tarballs"; while [[ $# -gt 0 ]]; do case "$1" in --url) url="$2"; shift 2;; --ref) ref="$2"; shift 2;; --name) name="$2"; shift 2;; --outdir) outdir="$2"; shift 2;; *) die 2 "Uso: lfsctl fetch git --url URL --ref REF --name NAME [--outdir DIR]";; esac; done; [[ -n "${url}" && -n "${ref}" && -n "${name}" ]] || die 2 "Faltam --url/--ref/--name"; with_flock "git-archive" 3600 bash -c 'dl_git_archive --url "'"${url}"'" --ref "'"${ref}"'" --name "'"${name}"'" --outdir "'"${outdir}"'"'; }
cmd_verify() { dl_bootstrap; local file sha sig="" keyring="${LFS_KEYS_DIR}"; [[ -n "${1:-}" ]] || die 2 "Uso: lfsctl verify <FILE> --sha256 HEX [--sig SIGFILE] [--keyring DIR]"; file="$1"; shift; while [[ $# -gt 0 ]]; do case "$1" in --sha256) sha="$2"; shift 2;; --sig) sig="$2"; shift 2;; --keyring) keyring="$2"; shift 2;; *) die 2 "Parâmetro inválido: $1";; esac; done; [[ -f "${file}" ]] || die 2 "Arquivo não encontrado: ${file}"; [[ -n "${sha:-}" ]] || die 2 "Falta --sha256"; dl_verify_sha256 "${file}" "${sha}"; [[ -n "${sig}" ]] && dl_verify_gpg "${file}" "${sig}" "${keyring}"; }
cmd_cache_ls() { dl_bootstrap; local which="${1:-all}"; case "${which}" in all) printf "sources:\n"; ls -1 "${LFS_CACHE}/sources" 2>/dev/null || true; printf "\n tarballs:\n"; ls -1 "${LFS_CACHE}/tarballs" 2>/dev/null || true; printf "\n git:\n"; ls -1 "${LFS_CACHE}/git" 2>/dev/null || true ;; sources) ls -lh "${LFS_CACHE}/sources" 2>/dev/null || true ;; tarballs) ls -lh "${LFS_CACHE}/tarballs" 2>/dev/null || true ;; git) ls -lh "${LFS_CACHE}/git" 2>/dev/null || true ;; *) die 2 "cache ls [sources|tarballs|git|all]";; esac; }
cmd_cache_clean() { assert_root; dl_bootstrap; local which="${1:-all}"; case "${which}" in all) rm -rf "${LFS_CACHE}/sources"/* "${LFS_CACHE}/tarballs"/* "${LFS_CACHE}/git"/* 2>/dev/null || true ;; sources) rm -rf "${LFS_CACHE}/sources"/* 2>/dev/null || true ;; tarballs) rm -rf "${LFS_CACHE}/tarballs"/* 2>/dev/null || true ;; git) rm -rf "${LFS_CACHE}/git"/* 2>/dev/null || true ;; *) die 2 "cache clean [sources|tarballs|git|all]";; esac; log_ok "Cache limpo: ${which}"; }

#-------------------------
# Chroot & Bootstrap (M3)
#-------------------------
cmd_chroot_init()   { assert_root; bootstrap_prepare; }
cmd_chroot_mount()  { assert_root; mount_all; }
cmd_chroot_umount() { assert_root; umount_all; }
cmd_chroot_status() {
  bootstrap_runtime
  echo "== CHROOT STATUS (${LFS_ROOT}) =="
  mount | grep "${LFS_ROOT}" || echo "(Sem mounts sobre ${LFS_ROOT})"
  if [[ -f "${LFS_ROOT}/etc/resolv.conf" ]]; then echo "DNS OK (resolv.conf presente)"; else echo "DNS ausente (sem /etc/resolv.conf)"; fi
}
cmd_chroot_enter() {
  assert_root
  if [[ "${1:-}" == "--" ]]; then shift; [[ "$#" -ge 1" " ]] || die 2 "Uso: lfsctl chroot enter [-- CMD ...]"; local cmd="$*"; chroot_exec "${cmd}"; else chroot_shell; fi
}
cmd_chroot_exec() {
  assert_root
  [[ "${1:-}" == "--" ]] || die 2 "Uso: lfsctl chroot exec -- CMD..."
  shift
  [[ "$#" -ge 1 ]] || die 2 "Falta comando para executar"
  chroot_exec "$*"
}
cmd_destdir_run() {
  bootstrap_runtime
  local dest=""
  [[ "${1:-}" == "--dest" ]] || die 2 "Uso: lfsctl destdir run --dest DIR -- CMD..."
  shift
  dest="$1"; shift
  [[ "${1:-}" == "--" ]] || die 2 "Uso: lfsctl destdir run --dest DIR -- CMD..."
  shift
  [[ "$#" -ge 1 ]] || die 2 "Falta comando para executar"
  destdir_run "${dest}" "$*"
}

#-------------------------
# Dispatcher
#-------------------------
main() {
  local cmd="${1:-}"; shift || true
  case "${cmd}" in
    ""|-h|--help|help) usage ;;
    # Core
    version)           cmd_version ;;
    init)              cmd_init ;;
    doctor)            cmd_doctor ;;
    status)            cmd_status ;;
    logs)              cmd_logs "${1:-}" ;;
    log-demo|logdemo)  cmd_log_demo ;;
    lock)              case "${1:-}" in test) shift; cmd_lock_test "${1:-example}";; *) usage; exit 2;; esac ;;
    config)            case "${1:-}" in print) shift; cmd_config_print ;; set) shift; cmd_config_set "$@" ;; *) usage; exit 2 ;; esac ;;
    # Downloader
    fetch)             case "${1:-}" in url) shift; cmd_fetch_url "$@" ;; list) shift; cmd_fetch_list "$@" ;; git) shift; cmd_fetch_git "$@" ;; *) usage; exit 2 ;; esac ;;
    verify)            cmd_verify "$@" ;;
    cache)             case "${1:-}" in ls) shift; cmd_cache_ls "${1:-all}" ;; clean) shift; cmd_cache_clean "${1:-all}" ;; *) usage; exit 2 ;; esac ;;
    # Chroot & Bootstrap
    chroot)            case "${1:-}" in init) shift; cmd_chroot_init ;; mount) shift; cmd_chroot_mount ;; umount) shift; cmd_chroot_umount ;; status) shift; cmd_chroot_status ;; enter) shift; cmd_chroot_enter "$@" ;; exec) shift; cmd_chroot_exec "$@" ;; *) usage; exit 2 ;; esac ;;
    destdir)           case "${1:-}" in run) shift; cmd_destdir_run "$@" ;; *) usage; exit 2 ;; esac ;;
    # Fallback
    *)
      log_error "Comando desconhecido: ${cmd}"
      usage
      exit 2
      ;;
  esac
}

main "$@"
