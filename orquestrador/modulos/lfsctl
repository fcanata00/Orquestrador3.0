#!/usr/bin/env bash
# lfsctl — CLI (M1+M2+M3+M4)
set -euo pipefail

: "${LFS_RUNTIME:=/usr/local/lib/lfs}"
# shellcheck source=/usr/local/lib/lfs/common.sh
. "${LFS_RUNTIME}/common.sh"
# shellcheck source=/usr/local/lib/lfs/downloader.sh
. "${LFS_RUNTIME}/downloader.sh"
# shellcheck source=/usr/local/lib/lfs/chroot.sh
. "${LFS_RUNTIME}/chroot.sh"
# shellcheck source=/usr/local/lib/lfs/recipes.sh
. "${LFS_RUNTIME}/recipes.sh"
# shellcheck source=/usr/local/lib/lfs/builder.sh"
. "${LFS_RUNTIME}/builder.sh"

VERSION="1.3.0"

usage() {
  cat <<'USAGE'
lfsctl 1.3.0
Uso: lfsctl <comando> [opções]

Core:
  version                     Mostra versão
  init                        Cria diretórios padrão e config inicial
  doctor                      Verifica dependências do ambiente
  status                      Mostra resumo de configuração/paths
  logs [N]                    Mostra últimas N linhas de log
  log-demo                    Gera entradas de log
  lock test [NAME]            Testa lock
  config print                Exibe config efetiva
  config set KEY=VAL [...]    Atualiza/insere chaves

Downloader & Cache:
  fetch url <URL> --sha256 HEX [--sig SIG] [--outdir DIR] [--name FILENAME]
  fetch list <FILE> [--parallel N] [--outdir DIR]
  fetch git --url URL --ref REF --name NAME [--outdir DIR]
  verify <FILE> --sha256 HEX [--sig SIGFILE] [--keyring DIR]
  cache ls [sources|tarballs|git]
  cache clean [sources|tarballs|git|all]

Chroot & Bootstrap:
  chroot init|mount|umount|status
  chroot enter [-- CMD...]    Entra no chroot ou executa CMD
  chroot exec -- CMD...       Executa CMD não interativo no chroot
  destdir run --dest DIR -- CMD...

Receitas & Build:
  recipe path <name>          Mostra caminho da receita
  recipe print <name>         Mostra receita normalizada
  recipe lint <name>          Valida receita
  deps graph <name>           Imprime ordem topológica (com dependências)
  deps tree <name>            Árvore de dependências
  build <name> [--rebuild] [--force] [--jobs N] [--chroot]
  build list <arquivo> [--jobs N] [--rebuild] [--force] [--chroot]

Observações:
  - Receitas são Bash em: /var/lib/lfs/recipes ou /usr/local/share/lfs/recipes
  - Campos mínimos: NAME, VERSION; fontes em arrays SOURCE/STA256 e patches em PATCHES/PATCHES_SHA256.
  - Staging (DESTDIR) padrão: /mnt/lfs/pkg/<name>-<version>
USAGE
}

# ==== Core (M1) ====
cmd_version() { echo "lfsctl ${VERSION}"; }
cmd_init()    { assert_root; log_info "Inicializando..."; bootstrap_runtime; log_ok "OK."; print_env_summary | sed 's/^/  - /'; }
cmd_doctor()  { bootstrap_runtime; log_info "Verificando dependências..."; if doctor_checks; then log_ok "Ambiente OK."; else log_error "Dependências faltantes."; exit 2; fi; }
cmd_status()  { bootstrap_runtime; echo "== STATUS =="; print_env_summary; echo; echo "Locks: ${LFS_LOCK_DIR}"; echo "DB: ${LFS_DB_DIR}"; echo "Receitas: ${LFS_RECIPES_DIR}"; echo "Logs: ${LFS_LOG_FILE}"; }
cmd_logs()    { bootstrap_runtime; tail_logs "${1:-200}"; }
cmd_log_demo(){ bootstrap_runtime; log_info "Info"; log_ok "OK"; log_warn "Warn"; log_error "Erro"; log_debug "Debug"; echo "Log: ${LFS_LOG_FILE}"; }
cmd_lock_test(){ bootstrap_runtime; local name="${1:-example}"; with_flock "${name}" 5 bash -c 'sleep 1'; log_ok "Lock ok"; }
cmd_config_print(){ bootstrap_runtime; echo "# Config efetiva"; print_env_summary; echo; echo "# Arquivos:"; echo "  - ${LFS_DEFAULT_CONFIG_FILE}"; if compgen -G "${LFS_ETC_D}/*.conf" >/dev/null; then for cf in "${LFS_ETC_D}"/*.conf; do echo "  - ${cf}"; done; else echo "  - (sem overrides)"; fi; }
cmd_config_set(){ assert_root; bootstrap_runtime; [[ "$#" -ge 1 ]] || die 2 "Uso: lfsctl config set KEY=VAL [...]"; local kv key val; touch "${LFS_DEFAULT_CONFIG_FILE}"; chmod 0644 "${LFS_DEFAULT_CONFIG_FILE}"; for kv in "$@"; do [[ "$kv" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]] || die 2 "Par inválido: ${kv}"; key="${kv%%=*}"; val="${kv#*=}"; if grep -qE "^${key}=" "${LFS_DEFAULT_CONFIG_FILE}"; then sed -i -E "s|^${key}=.*|${key}=${val}|g" "${LFS_DEFAULT_CONFIG_FILE}"; else echo "${key}=${val}" >> "${LFS_DEFAULT_CONFIG_FILE}"; fi; log_ok "${key}=${val}"; done; }

# ==== Downloader (M2) ====
cmd_fetch_url() { dl_bootstrap; local url sha sig="" outdir="${LFS_CACHE}/sources" name=""; [[ "${1:-}" =~ ^https?:// ]] || die 2 "Uso: lfsctl fetch url <URL> --sha256 HEX [--sig SIG] [--outdir DIR] [--name FILENAME]"; url="$1"; shift; while [[ $# -gt 0 ]]; do case "$1" in --sha256) sha="$2"; shift 2;; --sig) sig="$2"; shift 2;; --outdir) outdir="$2"; shift 2;; --name) name="$2"; shift 2;; *) die 2 "Parâmetro inválido: $1";; esac; done; [[ -n "${sha:-}" ]] || die 2 "Falta --sha256"; local fname; if [[ -n "${name}" ]]; then fname="${name}"; else fname="$(basename -- "$url")"; fi; local out="${outdir}/${fname}"; with_flock "fetch" 600 bash -c 'dl_fetch_one "'"${fname}"'" "'"${url}"'" "'"${sha}"'" "'"${sig}"'" "'"${outdir}"'" >/dev/null'; echo "${out}"; }
cmd_fetch_list() { dl_bootstrap; local list="${1:-}"; shift || true; [[ -n "${list}" ]] || die 2 "Uso: lfsctl fetch list <FILE> [--parallel N] [--outdir DIR]"; local parallel="$(effective_jobs)" outdir="${LFS_CACHE}/sources"; while [[ $# -gt 0 ]]; do case "$1" in --parallel) parallel="$2"; shift 2;; --outdir) outdir="$2"; shift 2;; *) die 2 "Parâmetro inválido: $1";; esac; done; with_flock "fetch" 3600 bash -c 'dl_fetch_list "'"${list}"'" "'"${outdir}"'" "'"${parallel}"'"'; }
cmd_fetch_git() { dl_bootstrap; local url="" ref="" name="" outdir="${LFS_CACHE}/tarballs"; while [[ $# -gt 0 ]]; do case "$1" in --url) url="$2"; shift 2;; --ref) ref="$2"; shift 2;; --name) name="$2"; shift 2;; --outdir) outdir="$2"; shift 2;; *) die 2 "Uso: lfsctl fetch git --url URL --ref REF --name NAME [--outdir DIR]";; esac; done; [[ -n "${url}" && -n "${ref}" && -n "${name}" ]] || die 2 "Faltam --url/--ref/--name"; with_flock "git-archive" 3600 bash -c 'dl_git_archive --url "'"${url}"'" --ref "'"${ref}"'" --name "'"${name}"'" --outdir "'"${outdir}"'"'; }
cmd_verify() { dl_bootstrap; local file sha sig="" keyring="${LFS_KEYS_DIR}"; [[ -n "${1:-}" ]] || die 2 "Uso: lfsctl verify <FILE> --sha256 HEX [--sig SIGFILE] [--keyring DIR]"; file="$1"; shift; while [[ $# -gt 0 ]]; do case "$1" in --sha256) sha="$2"; shift 2;; --sig) sig="$2"; shift 2;; --keyring) keyring="$2"; shift 2;; *) die 2 "Parâmetro inválido: $1";; esac; done; [[ -f "${file}" ]] || die 2 "Arquivo não encontrado: ${file}"; [[ -n "${sha:-}" ]] || die 2 "Falta --sha256"; dl_verify_sha256 "${file}" "${sha}"; [[ -n "${sig}" ]] && dl_verify_gpg "${file}" "${sig}" "${keyring}"; }
cmd_cache_ls() { dl_bootstrap; local which="${1:-all}"; case "${which}" in all) printf "sources:\n"; ls -1 "${LFS_CACHE}/sources" 2>/dev/null || true; printf "\n tarballs:\n"; ls -1 "${LFS_CACHE}/tarballs" 2>/dev/null || true; printf "\n git:\n"; ls -1 "${LFS_CACHE}/git" 2>/dev/null || true ;; sources) ls -lh "${LFS_CACHE}/sources" 2>/dev/null || true ;; tarballs) ls -lh "${LFS_CACHE}/tarballs" 2>/dev/null || true ;; git) ls -lh "${LFS_CACHE}/git" 2>/dev/null || true ;; *) die 2 "cache ls [sources|tarballs|git|all]";; esac; }
cmd_cache_clean() { assert_root; dl_bootstrap; local which="${1:-all}"; case "${which}" in all) rm -rf "${LFS_CACHE}/sources"/* "${LFS_CACHE}/tarballs"/* "${LFS_CACHE}/git"/* 2>/dev/null || true ;; sources) rm -rf "${LFS_CACHE}/sources"/* 2>/dev/null || true ;; tarballs) rm -rf "${LFS_CACHE}/tarballs"/* 2>/dev/null || true ;; git) rm -rf "${LFS_CACHE}/git"/* 2>/dev/null || true ;; *) die 2 "cache clean [sources|tarballs|git|all]";; esac; log_ok "Cache limpo: ${which}"; }

# ==== Chroot (M3) ====
cmd_chroot_init()   { assert_root; bootstrap_prepare; }
cmd_chroot_mount()  { assert_root; mount_all; }
cmd_chroot_umount() { assert_root; umount_all; }
cmd_chroot_status() { bootstrap_runtime; echo "== CHROOT STATUS (/mnt/lfs) =="; mount | grep "/mnt/lfs" || echo "(Sem mounts)"; [[ -f "/mnt/lfs/etc/resolv.conf" ]] && echo "DNS OK" || echo "DNS ausente"; }
cmd_chroot_enter()  { assert_root; if [[ "${1:-}" == "--" ]]; then shift; [[ "$#" -ge 1 ]] || die 2 "Uso: lfsctl chroot enter [-- CMD ...]"; chroot_exec "$*"; else chroot_shell; fi }
cmd_chroot_exec()   { assert_root; [[ "${1:-}" == "--" ]] || die 2 "Uso: lfsctl chroot exec -- CMD..."; shift; [[ "$#" -ge 1 ]] || die 2 "Falta comando"; chroot_exec "$*"; }
cmd_destdir_run()   { bootstrap_runtime; [[ "${1:-}" == "--dest" ]] || die 2 "Uso: lfsctl destdir run --dest DIR -- CMD..."; shift; local dest="$1"; shift; [[ "${1:-}" == "--" ]] || die 2 "Uso: lfsctl destdir run --dest DIR -- CMD..."; shift; [[ "$#" -ge 1 ]] || die 2 "Falta comando"; destdir_run "${dest}" "$*"; }

# ==== Receitas & Build (M4) ====
cmd_recipe_path()  { recipes_bootstrap; local n="${1:-}"; [[ -n "${n}" ]] || die 2 "Uso: lfsctl recipe path <name>"; local p; if p="$(recipe_path "${n}")"; then echo "${p}"; else die 1 "Receita não encontrada: ${n}"; fi; }
cmd_recipe_print() { recipes_bootstrap; local n="${1:-}"; [[ -n "${n}" ]] || die 2 "Uso: lfsctl recipe print <name>"; recipe_print "${n}"; }
cmd_recipe_lint()  { recipes_bootstrap; local n="${1:-}"; [[ -n "${n}" ]] || die 2 "Uso: lfsctl recipe lint <name>"; recipe_lint "${n}"; }
cmd_deps_graph()   { recipes_bootstrap; local n="${1:-}"; [[ -n "${n}" ]] || die 2 "Uso: lfsctl deps graph <name>"; deps_graph "${n}"; }
cmd_deps_tree()    { recipes_bootstrap; local n="${1:-}"; [[ -n "${n}" ]] || die 2 "Uso: lfsctl deps tree <name>"; deps_tree "${n}"; }
cmd_build_one()    {
  builder_bootstrap
  local name="${1:-}"; shift || true
  [[ -n "${name}" ]] || die 2 "Uso: lfsctl build <name> [--rebuild] [--force] [--jobs N] [--chroot]"
  local rebuild=0 force=0 jobs="$(effective_jobs)" use_chroot=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --rebuild) rebuild=1; shift ;;
      --force)   force=1; shift ;;
      --jobs)    jobs="$2"; shift 2 ;;
      --chroot)  use_chroot=1; shift ;;
      *) die 2 "Parâmetro inválido: $1" ;;
    esac
  done
  build_with_deps "${name}" "${jobs}" "${rebuild}" "${use_chroot}" "${force}"
}
cmd_build_list()   {
  builder_bootstrap
  local list="${1:-}"; shift || true
  [[ -f "${list}" ]] || die 2 "Arquivo não encontrado: ${list}"
  local rebuild=0 force=0 jobs="$(effective_jobs)" use_chroot=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --rebuild) rebuild=1; shift ;;
      --force)   force=1; shift ;;
      --jobs)    jobs="$2"; shift 2 ;;
      --chroot)  use_chroot=1; shift ;;
      *) die 2 "Parâmetro inválido: $1" ;;
    esac
  done
  local name
  while IFS= read -r name; do
    [[ -z "${name}" || "${name:0:1}" == "#" ]] && continue
    build_with_deps "${name}" "${jobs}" "${rebuild}" "${use_chroot}" "${force}"
  done < "${list}"
}

# ---- Dispatcher ----
main() {
  local cmd="${1:-}"; shift || true
  case "${cmd}" in
    ""|-h|--help|help) usage ;;
    # Core
    version) cmd_version ;;
    init)    cmd_init ;;
    doctor)  cmd_doctor ;;
    status)  cmd_status ;;
    logs)    cmd_logs "${1:-}" ;;
    log-demo|logdemo) cmd_log_demo ;;
    lock)    case "${1:-}" in test) shift; cmd_lock_test "${1:-example}";; *) usage; exit 2;; esac ;;
    config)  case "${1:-}" in print) shift; cmd_config_print ;; set) shift; cmd_config_set "$@" ;; *) usage; exit 2 ;; esac ;;
    # Downloader
    fetch)   case "${1:-}" in url) shift; cmd_fetch_url "$@" ;; list) shift; cmd_fetch_list "$@" ;; git) shift; cmd_fetch_git "$@" ;; *) usage; exit 2 ;; esac ;;
    verify)  cmd_verify "$@" ;;
    cache)   case "${1:-}" in ls) shift; cmd_cache_ls "${1:-all}" ;; clean) shift; cmd_cache_clean "${1:-all}" ;; *) usage; exit 2 ;; esac ;;
    # Chroot
    chroot)  case "${1:-}" in init) shift; cmd_chroot_init ;; mount) shift; cmd_chroot_mount ;; umount) shift; cmd_chroot_umount ;; status) shift; cmd_chroot_status ;; enter) shift; cmd_chroot_enter "$@" ;; exec) shift; cmd_chroot_exec "$@" ;; *) usage; exit 2 ;; esac ;;
    destdir) case "${1:-}" in run) shift; cmd_destdir_run "$@" ;; *) usage; exit 2 ;; esac ;;
    # Receitas & Build
    recipe)  case "${1:-}" in path) shift; cmd_recipe_path "$@" ;; print) shift; cmd_recipe_print "$@" ;; lint) shift; cmd_recipe_lint "$@" ;; *) usage; exit 2 ;; esac ;;
    deps)    case "${1:-}" in graph) shift; cmd_deps_graph "$@" ;; tree) shift; cmd_deps_tree "$@" ;; *) usage; exit 2 ;; esac ;;
    build)   case "${1:-}" in list) shift; cmd_build_list "$@" ;; *) cmd_build_one "${cmd}" "$@";; esac ;;  # Nota: "build <name>" captura aqui
    *)
      # Se usuário fizer "lfsctl build <name>" cai aqui: cmd é "build" já tratado acima,
      # mas se digitar outro nome solto, erro:
      log_error "Comando desconhecido: ${cmd}"
      usage
      exit 2
      ;;
  esac
}

main "$@"
